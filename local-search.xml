<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT 6.5840(6.824) | Lab1: MapReduce</title>
    <link href="/2023/08/07/MIT-6-5840-6-824-Lab1-MapReduce/"/>
    <url>/2023/08/07/MIT-6-5840-6-824-Lab1-MapReduce/</url>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>本篇文章主要讲解我的无显式锁MapReduce实现思路，在开始之前建议先熟悉Go语言并阅读过MapReduce的<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">论文</a>或了解过MapReduce的原理。</p><p>使用IDE编写代码可以很方便的进行调试，这里使用Goland。关于项目的配置可以参考这篇<a href="https://zhuanlan.zhihu.com/p/260752052">知乎文章</a>（并不建议阅读他的代码，很显然作者是从Java语言转过来的，一些数据结构显得比较多余）。</p><p>无显式锁的思路主要受2021年Russ Cox的<a href="https://www.bilibili.com/video/BV16f4y1z7kn">guest lecture</a>启发, 其中的scheduler模式十分适用于实现MapReduce.</p><p>建议使用最新版本的<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">代码模板</a>开始你的任务，相较于之前的散装代码，这个版本使用了gomod，并且减少了IDE中烦人的报错。同时，建议读者应该仔细阅读lab的rules与hint，对理解任务与代码编写都有很大的帮助。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Task的定义"><a href="#Task的定义" class="headerlink" title="Task的定义"></a>Task的定义</h3><p>Task是需要通过RPC进行传递的，因此首先定义一下Task.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TaskType <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>MapState TaskType = <span class="hljs-literal">iota</span><br>ReduceState<br>WaitState<br>CompleteState<br>)<br><br><span class="hljs-keyword">type</span> TaskStatus <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>Init TaskStatus = <span class="hljs-literal">iota</span><br>Working<br>Complete<br>)<br><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>FileName   <span class="hljs-type">string</span><br>TaskType   TaskType<br>TaskStatus TaskStatus<br>NReduce    <span class="hljs-type">int</span><br>FileId     <span class="hljs-type">int</span><br>StartTime  time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>相较于区分map任务与reduce任务，我认为两者共用一个struct即可，无需为两者做出区分。在编写代码时，你应该随着你的编码进度来修改task的结构，而不是直接照抄，这样会大大限制你的思考。</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Worker的实现比较简单，只需要对分配到的任务做出相应处理即可。注意，你应该有一个wait task，来应对一些需要worker等待的情况，例如hints里提到在开始reduce任务之前你需要等待map任务结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue,<br>reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;<br><br>task := AskTask(&amp;Task&#123;&#125;)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">switch</span> task.TaskType &#123;<br><span class="hljs-keyword">case</span> MapState:<br>task = DoMap(&amp;task, mapf)<br><span class="hljs-keyword">case</span> ReduceState:<br>task = DoReduce(&amp;task, reducef)<br><span class="hljs-keyword">case</span> WaitState:<br>fmt.Printf(<span class="hljs-string">&quot;wait for task\n&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>task = Task&#123;TaskType: WaitState&#125;<br><span class="hljs-keyword">case</span> CompleteState:<br><span class="hljs-keyword">return</span><br>&#125;<br>task = AskTask(&amp;task)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在中间文件的创建与读取中有一些细节需要注意，这里参考hints里提到的就好了。在worker完成当前任务并请求下一个任务的过程中，我将当前完成的任务作为参数发送给coordinator，方便coordinator对task进行状态维护（从workingChan转移至DoneChan）。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>在包括空行的情况下我仅仅用了133行代码实现了coordinator, 这主要归功于channel的使用与不维护worker状态的设计。</p><p>我对于Coordinator的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;<br>taskChan    <span class="hljs-keyword">chan</span> Task<br>workingChan <span class="hljs-keyword">chan</span> Task<br>DoneChan    <span class="hljs-keyword">chan</span> Task<br>files       []<span class="hljs-type">string</span><br>phase       CoordinatorPhase<br>nReduce     <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我定义了三个channel，这次大规模使用channel让我体会到对于多线程分布式的任务，它的存在会简化我们的许多工作。<code>DoneChan</code>实际上有点多余，由于不需要知道<code>DoneChan</code>中task任务的具体信息，只需要知道task的数量，使用一个bool类型的数组也可以完成它的工作。</p><p>Coordinator的工作流程主要如下：</p><ol><li>将任务打入taskChan</li><li>接到worker任务请求，从workingChan取出worker发来的已完成任务并打入DoneChan</li><li>遍历workingChan查看是否有超时任务，如果超时则取出并放回taskChan供重新分配</li><li>从taskChan取出任务分配给worker后，将其打入workingChan</li></ol><p>可以发现只需要维护task的状态即可，并不需要关注worker的状态，如果worker没能完成这个任务，交给其他worker完成就可以了。</p><p>至于map阶段，reduce阶段与所有任务完成阶段的转换，只需要在每次call Done函数时进行判断，如果此时DoneChan中的任务数量与需要完成的数量相同，就可以判断此阶段完成，可以开启下一阶段了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MIT6.5840</tag>
      
      <tag>分布式系统</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
