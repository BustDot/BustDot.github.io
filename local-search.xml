<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT 6.5840(6.824) | GFS Note</title>
    <link href="/2023/08/08/MIT-6-5840-6-824-GFS-Note/"/>
    <url>/2023/08/08/MIT-6-5840-6-824-GFS-Note/</url>
    
    <content type="html"><![CDATA[<p>本篇文章为GFS的学习笔记。</p><span id="more"></span><h2 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h2><p>一致性，性能与价格的不可能三角。</p><h2 id="GFS-master"><a href="#GFS-master" class="headerlink" title="GFS master"></a>GFS master</h2><p>Master为Active-Standby模式，所以只有一个Master节点在工作。Master节点保存了文件名和存储位置的对应关系。</p><p>Master节点主要存储两个表单：</p><p>第一个是文件名到Chunk ID或者Chunk Handle数组的对应。这个表单告诉你，文件对应了哪些Chunk。但是只有Chunk ID是做不了太多事情的，所以有了第二个表单。</p><p>第二个表单记录了Chunk ID到Chunk数据的对应关系。这里的数据又包括了：</p><ul><li>每个Chunk存储在哪些服务器上，所以这部分是Chunk服务器的列表</li><li>每个Chunk当前的版本号，所以Master节点必须记住每个Chunk对应的版本号。</li><li>所有对于Chunk的写操作都必须在主Chunk（Primary Chunk）上顺序处理，主Chunk是Chunk的多个副本之一。所以，Master节点必须记住哪个Chunk服务器持有主Chunk。</li><li>并且，主Chunk只能在特定的租约时间内担任主Chunk，所以，Master节点要记住主Chunk的租约过期时间。</li></ul><p>为了保证master节点重启后不丢失，一部分数据需要写入log。Master节点读数据只会从内存读，但是写数据的时候，至少有一部分数据会接入到磁盘中。更具体来说，Master会在磁盘上存储log，每次有数据变更时，Master会在磁盘的log中追加一条记录，并生成CheckPoint（类似于备份点）。</p><p class="note note-info">为什么在磁盘中维护log而不是数据库？<br><br>数据库本质上来说是某种B树（b-tree）或者hash table，相比之下，追加log会非常的高效，因为你可以将最近的多个log记录一次性的写入磁盘。因为这些数据都是向同一个地址追加，这样只需要等待磁盘的磁碟旋转一次。而对于B树来说，每一份数据都需要在磁盘中随机找个位置写入。所以使用Log可以使得磁盘写入更快一些。</p><p>有些数据需要存在磁盘上，而有些不用。它们分别是：</p><ul><li>Chunk Handle的数组（第一个表单）要保存在磁盘上。我给它标记成NV（non-volatile, 非易失），这个标记表示对应的数据会写入到磁盘上。</li><li>Chunk服务器列表不用保存到磁盘上。因为Master节点重启之后可以与所有的Chunk服务器通信，并查询每个Chunk服务器存储了哪些Chunk，所以我认为它不用写入磁盘。所以这里标记成V（volatile），</li><li>版本号要不要写入磁盘取决于GFS是如何工作的，我认为它需要写入磁盘。我们之后在讨论系统是如何工作的时候再详细讨论这个问题。这里先标记成NV。</li><li>主Chunk的ID，几乎可以确定不用写入磁盘，因为Master节点重启之后会忘记谁是主Chunk，它只需要等待60秒租约到期，那么它知道对于这个Chunk来说没有主Chunk，这个时候，Master节点可以安全指定一个新的主Chunk。所以这里标记成V。</li><li>类似的，租约过期时间也不用写入磁盘，所以这里标记成V。</li></ul><p>任何时候，如果文件扩展到达了一个新的64MB，需要新增一个Chunk或者由于指定了新的主Chunk而导致版本号更新了，Master节点需要向磁盘中的Log追加一条记录说，我刚刚向这个文件添加了一个新的Chunk或者我刚刚修改了Chunk的版本号。所以每次有这样的更新，都需要写磁盘。GFS论文并没有讨论这么多细节，但是因为写磁盘的速度是有限的，写磁盘会导致Master节点的更新速度也是有限的，所以要尽可能少的写入数据到磁盘。</p><h2 id="GFS读文件"><a href="#GFS读文件" class="headerlink" title="GFS读文件"></a>GFS读文件</h2><ol><li>客户端向master节点发送想要读取的文件名与想要读取数据在该文件中偏移量</li><li>Master节点会从自己的file表单中查询文件名，得到Chunk ID的数组。偏移量除以Chunk大小64MB就可以从数组中得到对应的Chunk ID。再从Chunk表单中找到存有Chunk的服务器列表，并将列表返回给客户端。</li><li>客户端从Chunk服务器中选一个网络上最近的服务器并向其发送读请求。同时，Chunk与服务器对应关系会被客户端缓存下来，再一次请求时则不用经过master节点。</li><li>Chunk服务器根据Chunk ID找到对应的Chunk文件，之后从文件中读取对应的数据段，并将数据返回给客户端。</li></ol><p class="note note-info">如果读取的数据超过了一个Chunk怎么办？<br><br>Robert教授：客户端本身依赖了一个GFS的库，这个库会注意到读请求跨越了Chunk的边界 ，并会将读请求拆分，之后再将它们合并起来。所以这个库会与Master节点交互，Master节点会告诉这个库说Chunk7在这个服务器，Chunk8在那个服务器。之后这个库会说，我需要Chunk7的最后两个字节，Chunk8的头两个字节。GFS库获取到这些数据之后，会将它们放在一个buffer中，再返回给调用库的应用程序。Master节点会告诉库有关Chunk的信息，而GFS库可以根据这个信息找到应用程序想要的数据。应用程序只需要确定文件名和数据在整个文件中的偏移量，GFS库和Master节点共同协商将这些信息转换成Chunk。</p><p class="note note-info">从哪个Chunk服务器读取数据重要吗？<br><br>Robert教授：是也不是。概念上讲，它们都是副本。实际上，你可能已经注意到，或者我们之前也说过，不同Chunk服务器上的数据并不一定完全相同。应用程序应该要能够容忍这种情况。所以，实际上，如果从不同的Chunk服务器读取数据，可能会略微不同。GFS论文提到，客户端会尝试从同一个机架或者同一个交换机上的服务器读取数据。</p><h2 id="GFS写文件"><a href="#GFS写文件" class="headerlink" title="GFS写文件"></a>GFS写文件</h2><h3 id="1-查找主副本"><a href="#1-查找主副本" class="headerlink" title="1. 查找主副本"></a>1. 查找主副本</h3><p>客户端向Master节点发送写请求并查询哪个Chunk服务器保存了文件的最后一个Chunk。</p><p>master找出chunk的主副本。如果发现Chunk的主副本不存在，Master会找出所有存有Chunk最新副本的Chunk服务器。（如果一个系统已经运行了很长时间，那么有可能某一个Chunk服务器保存的Chunk副本是旧的，比如说还是昨天或者上周的。导致这个现象的原因可能是服务器因为宕机而没有收到任何的更新。）最新的副本是指，副本中保存的版本号与Master中记录的Chunk的版本号一致。Chunk副本中的版本号是由Master节点下发的，所以Master节点知道，对于一个特定的Chunk，哪个版本号是最新的。</p><p class="note note-info">为什么不将所有Chunk服务器上保存的最大版本号作为Chunk的最新版本号？<br><br>Robert教授：当Master重启时，无论如何都需要与所有的Chunk服务器进行通信，因为Master需要确定哪个Chunk服务器存了哪个Chunk。你可能会想到，Master可以将所有Chunk服务器上的Chunk版本号汇总，找出里面的最大值作为最新的版本号。如果所有持有Chunk的服务器都响应了，那么这种方法是没有问题的。但是存在一种风险，当Master节点重启时，可能部分Chunk服务器离线或者失联或者自己也在重启，从而不能响应Master节点的请求。所以，Master节点可能只能获取到持有旧副本的Chunk服务器的响应，而持有最新副本的Chunk服务器还没有完成重启，或者还是离线状态（这个时候Master能找到的Chunk最大版本明显不对）。当Master找不到持有最新Chunk的服务器时该怎么办？Master节点会定期与Chunk服务器交互来查询它们持有什么样版本的Chunk。假设Master保存的Chunk版本是17，但是又没有找到存储了版本号是17的Chunk服务器，那么有两种可能：要么Master会等待，并不响应客户端的请求；要么会返回给客户端说，我现在还不知道Chunk在哪，过会再重试吧。比如说机房电源故障了，所有的服务器都崩溃了，我们正在缓慢的重启。Master节点和一些Chunk服务器可能可以先启动起来，一些Chunk服务器可能要5分钟以后才能重启，这种场景下，我们需要等待，甚至可能是永远等待，因为你不会想使用Chunk的旧数据。所以，总的来说，在重启时，因为Master从磁盘存储的数据知道Chunk对应的最新版本，Master节点会整合具有最新版本Chunk的服务器。每个Chunk服务器会记住本地存储Chunk对应的版本号，当Chunk服务器向Master汇报时，就可以说，我有这个Chunk的这个版本。而Master节点就可以忽略哪些版本号与已知版本不匹配的Chunk服务器。</p><h3 id="2-Primary与Secondary服务器"><a href="#2-Primary与Secondary服务器" class="headerlink" title="2. Primary与Secondary服务器"></a>2. Primary与Secondary服务器</h3><p>Master等待所有存储了最新Chunk版本的服务器集合完成，然后挑选一个作为Primary，其他的作为Secondary。Master增加版本号，并将版本号写入磁盘。Master节点会向Primary和Secondary副本对应的服务器发送消息并告诉它们，谁是Primary，谁是Secondary，Chunk的新版本是什么。Primary和Secondary服务器都会将版本号存储在本地的磁盘中。这样，当它们因为电源故障或者其他原因重启时，它们可以向Master报告本地保存的Chunk的实际版本号。</p><p>Primary接收来自客户端的写请求，并将写请求应用在多个Chunk服务器中。之所以要管理Chunk的版本号，是因为这样Master可以将实际更新Chunk的能力转移给Primary服务器。并且在将版本号更新到Primary和Secondary服务器之后，如果Master节点故障重启，还是可以在相同的Primary和Secondary服务器上继续更新Chunk。</p><p>Master节点通知Primary和Secondary服务器可以修改这个Chunk。它还给Primary一个租约，这个租约告诉Primary说，在接下来的60秒中，你将是Primary，60秒之后你必须停止成为Primary。这种机制可以确保不会同时有两个Primary。</p><p>假设现在Master节点告诉客户端谁是Primary，谁是Secondary，GFS提出了一种聪明的方法来实现写请求的执行序列。客户端会将要追加的数据发送给Primary和Secondary服务器，这些服务器会将数据写入到一个临时位置。所以最开始，这些数据不会追加到文件中。当所有的服务器都返回确认消息说，已经有了要追加的数据，客户端会向Primary服务器发送一条消息说，你和所有的Secondary服务器都有了要追加的数据，现在我想将这个数据追加到这个文件中。Primary服务器或许会从大量客户端收到大量的并发请求，Primary服务器会以某种顺序，一次只执行一个请求。对于每个客户端的追加数据请求（也就是写请求），Primary会查看当前文件结尾的Chunk，并确保Chunk中有足够的剩余空间，然后将客户端要追加的数据写入Chunk的末尾。并且，Primary会通知所有的Secondary服务器也将客户端要追加的数据写入在它们自己存储的Chunk末尾。这样，包括Primary在内的所有副本，都会收到通知将数据追加在Chunk的末尾。</p><p>但是对于Secondary服务器来说，它们可能可以执行成功，也可能会执行失败，比如说磁盘空间不足，比如说故障了，比如说Primary发出的消息网络丢包了。如果Secondary实际真的将数据写入到了本地磁盘存储的Chunk中，它会回复“yes”给Primary。如果所有的Secondary服务器都成功将数据写入，并将“yes”回复给了Primary，并且Primary也收到了这些回复。Primary会向客户端返回写入成功。如果至少一个Secondary服务器没有回复Primary，或者回复了，但是内容却是：抱歉，一些不好的事情发生了，比如说磁盘空间不够，或者磁盘故障了，Primary会向客户端返回写入失败。如果客户端从Primary得到写入失败，那么客户端应该重新发起整个追加过程。客户端首先会重新与Master交互，找到文件末尾的Chunk；之后，客户端需要重新发起对于Primary和Secondary的数据追加操作。</p><h2 id="GFS的一致性"><a href="#GFS的一致性" class="headerlink" title="GFS的一致性"></a>GFS的一致性</h2><p><img src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MDlKCEjhSvXUjjI5-cA%2F-MDlMJ54nX5uNPISZ8vX%2Fimage.png?alt=media&token=9661caa0-ad11-4d50-892f-71f1ab069978" alt="B数据追加失败，再次追加后导致乱序"></p><p>GFS会出现乱序与未写入的情况。</p><h2 id="GFS的问题"><a href="#GFS的问题" class="headerlink" title="GFS的问题"></a>GFS的问题</h2><p>它最严重的局限可能在于，它只有一个Master节点，会带来以下问题：</p><ul><li>Master节点必须为每个文件，每个Chunk维护表单，随着GFS的应用越来越多，这意味着涉及的文件也越来越多，最终Master会耗尽内存来存储文件表单。你可以增加内存，但是单台计算机的内存也是有上限的。所以，这是人们遇到的最早的问题。</li><li>除此之外，单个Master节点要承载数千个客户端的请求，而Master节点的CPU每秒只能处理数百个请求，尤其Master还需要将部分数据写入磁盘，很快，客户端数量超过了单个Master的能力。</li><li>另一个问题是，应用程序发现很难处理GFS奇怪的语义（本节最开始介绍的GFS的副本数据的同步，或者可以说不同步）。</li><li>最后一个问题是，从我们读到的GFS论文中，Master节点的故障切换不是自动的。GFS需要人工干预来处理已经永久故障的Master节点，并更换新的服务器，这可能需要几十分钟甚至更长的而时间来处理。对于某些应用程序来说，这个时间太长了。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MIT6.5840</tag>
      
      <tag>分布式系统</tag>
      
      <tag>GFS</tag>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT 6.5840(6.824) | Lab1: MapReduce</title>
    <link href="/2023/08/07/MIT-6-5840-6-824-Lab1-MapReduce/"/>
    <url>/2023/08/07/MIT-6-5840-6-824-Lab1-MapReduce/</url>
    
    <content type="html"><![CDATA[<p>本篇文章主要讲解我的无显式锁MapReduce实现思路。</p><span id="more"></span><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>在开始之前建议先熟悉Go语言并阅读过MapReduce的<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">论文</a>或了解过MapReduce的原理。</p><p>使用IDE编写代码可以很方便的进行调试，这里使用Goland。关于项目的配置可以参考这篇<a href="https://zhuanlan.zhihu.com/p/260752052">知乎文章</a>（并不建议阅读他的代码，很显然作者是从Java语言转过来的，一些数据结构显得比较多余）。</p><p>无显式锁的思路主要受2021年Russ Cox的<a href="https://www.bilibili.com/video/BV16f4y1z7kn">guest lecture</a>启发, 其中的scheduler模式十分适用于实现MapReduce.</p><p>建议使用最新版本的<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">代码模板</a>开始你的任务，相较于之前的散装代码，这个版本使用了gomod，并且减少了IDE中烦人的报错。同时，建议读者应该仔细阅读lab的rules与hint，对理解任务与代码编写都有很大的帮助。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Task的定义"><a href="#Task的定义" class="headerlink" title="Task的定义"></a>Task的定义</h3><p>Task是需要通过RPC进行传递的，因此首先定义一下Task.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TaskType <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>MapState TaskType = <span class="hljs-literal">iota</span><br>ReduceState<br>WaitState<br>CompleteState<br>)<br><br><span class="hljs-keyword">type</span> TaskStatus <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>Init TaskStatus = <span class="hljs-literal">iota</span><br>Working<br>Complete<br>)<br><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>FileName   <span class="hljs-type">string</span><br>TaskType   TaskType<br>TaskStatus TaskStatus<br>NReduce    <span class="hljs-type">int</span><br>FileId     <span class="hljs-type">int</span><br>StartTime  time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p>相较于区分map任务与reduce任务，我认为两者共用一个struct即可，无需为两者做出区分。在编写代码时，你应该随着你的编码进度来修改task的结构，而不是直接照抄，这样会大大限制你的思考。</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Worker的实现比较简单，只需要对分配到的任务做出相应处理即可。注意，你应该有一个wait task，来应对一些需要worker等待的情况，例如hints里提到在开始reduce任务之前你需要等待map任务结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue,<br>reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;<br><br>task := AskTask(&amp;Task&#123;&#125;)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">switch</span> task.TaskType &#123;<br><span class="hljs-keyword">case</span> MapState:<br>task = DoMap(&amp;task, mapf)<br><span class="hljs-keyword">case</span> ReduceState:<br>task = DoReduce(&amp;task, reducef)<br><span class="hljs-keyword">case</span> WaitState:<br>fmt.Printf(<span class="hljs-string">&quot;wait for task\n&quot;</span>)<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>task = Task&#123;TaskType: WaitState&#125;<br><span class="hljs-keyword">case</span> CompleteState:<br><span class="hljs-keyword">return</span><br>&#125;<br>task = AskTask(&amp;task)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在中间文件的创建与读取中有一些细节需要注意，这里参考hints里提到的就好了。在worker完成当前任务并请求下一个任务的过程中，我将当前完成的任务作为参数发送给coordinator，方便coordinator对task进行状态维护（从workingChan转移至DoneChan）。</p><h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><p>在包括空行的情况下我仅仅用了133行代码实现了coordinator, 这主要归功于channel的使用与不维护worker状态的设计。</p><p>我对于Coordinator的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;<br>taskChan    <span class="hljs-keyword">chan</span> Task<br>workingChan <span class="hljs-keyword">chan</span> Task<br>DoneChan    <span class="hljs-keyword">chan</span> Task<br>files       []<span class="hljs-type">string</span><br>phase       CoordinatorPhase<br>nReduce     <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我定义了三个channel，这次大规模使用channel让我体会到对于多线程分布式的任务，它的存在会简化我们的许多工作。<code>DoneChan</code>实际上有点多余，由于不需要知道<code>DoneChan</code>中task任务的具体信息，只需要知道task的数量，使用一个bool类型的数组也可以完成它的工作。</p><p>Coordinator的工作流程主要如下：</p><ol><li>将任务打入taskChan</li><li>接到worker任务请求，从workingChan取出worker发来的已完成任务并打入DoneChan</li><li>遍历workingChan查看是否有超时任务，如果超时则取出并放回taskChan供重新分配</li><li>从taskChan取出任务分配给worker后，将其打入workingChan</li></ol><p>可以发现只需要维护task的状态即可，并不需要关注worker的状态，如果worker没能完成这个任务，交给其他worker完成就可以了。</p><p>至于map阶段，reduce阶段与所有任务完成阶段的转换，只需要在每次call Done函数时进行判断，如果此时DoneChan中的任务数量与需要完成的数量相同，就可以判断此阶段完成，可以开启下一阶段了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MIT6.5840</tag>
      
      <tag>分布式系统</tag>
      
      <tag>MapReduce</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
